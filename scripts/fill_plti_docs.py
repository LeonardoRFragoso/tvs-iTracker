import os
import re
import argparse
from datetime import datetime
from docx import Document

START_MARK = "--- AUTO-GERADO (INÍCIO) ---"
END_MARK = "--- AUTO-GERADO (FIM) ---"


def remove_autogenerated_sections(doc: Document):
    start_idx = None
    end_idx = None
    # Identify indices of start/end markers
    for i, p in enumerate(doc.paragraphs):
        if p.text.strip() == START_MARK and start_idx is None:
            start_idx = i
        if p.text.strip() == END_MARK:
            end_idx = i
    if start_idx is not None and end_idx is not None and end_idx >= start_idx:
        # Remove from end to start to keep indices valid
        for i in range(end_idx, start_idx - 1, -1):
            p = doc.paragraphs[i]
            p._element.getparent().remove(p._element)


def add_md_block(doc: Document, md_text: str):
    import textwrap
    lines = md_text.splitlines()
    # Insert START marker
    doc.add_paragraph(START_MARK)

    for raw in lines:
        line = raw.rstrip("\n")
        if not line.strip():
            doc.add_paragraph("")
            continue
        # Headings
        if line.startswith("### "):
            doc.add_heading(line[4:].strip(), level=3)
            continue
        if line.startswith("## "):
            doc.add_heading(line[3:].strip(), level=2)
            continue
        if line.startswith("# "):
            doc.add_heading(line[2:].strip(), level=1)
            continue
        # Bulleted list
        if line.lstrip().startswith("- ") or line.lstrip().startswith("* "):
            text = line.lstrip()[2:].strip()
            p = doc.add_paragraph(text)
            # Tentar aplicar estilo de lista; se não existir no template, manter padrão
            try:
                p.style = 'List Bullet'
            except Exception:
                pass
            continue
        # Numbered list (simple detection like '1. ')
        if re.match(r"^\s*\d+\.\s+", line):
            text = re.sub(r"^\s*\d+\.\s+", "", line).strip()
            p = doc.add_paragraph(text)
            # Tentar aplicar estilo numerado; se não existir no template, manter padrão
            try:
                p.style = 'List Number'
            except Exception:
                pass
            continue
        # Default paragraph
        doc.add_paragraph(line)

    # Insert END marker
    doc.add_paragraph(END_MARK)


def write_document(doc_path: str, content_md: str):
    if not os.path.exists(doc_path):
        raise FileNotFoundError(f"Arquivo não encontrado: {doc_path}")
    doc = Document(doc_path)
    remove_autogenerated_sections(doc)
    add_md_block(doc, content_md)
    doc.save(doc_path)


def main():
    parser = argparse.ArgumentParser(description='Preenche documentos PLTI-012*.docx com conteúdo auto-gerado.')
    parser.add_argument('--docs-dir', default=os.path.join(os.path.dirname(os.getcwd()), 'docs'), help='Diretório dos .docx (padrão: ../docs)')
    parser.add_argument('--remove-md', action='store_true', default=True, help='Remove arquivos .md auxiliares (padrão: True)')
    args = parser.parse_args()

    docs_dir = args.docs_dir
    today_str = datetime.now().strftime('%d/%m/%Y')

    # Caminhos dos .docx
    p012a = os.path.join(docs_dir, 'PLTI-012a - Documento_de_Escopo_As_is_To_be 8 1.docx')
    p012b = os.path.join(docs_dir, 'PLTI-012b - Arquitetura_de_Ti_To_Be 8.docx')
    p012c = os.path.join(docs_dir, 'PLTI-012c - As_Built 6.docx')
    p012d = os.path.join(docs_dir, 'PLTI-012d - Plano de Manutenção e Suporte da Aplicação 5.docx')

    # Conteúdo: PLTI-012a
    content_012a = f"""
# PLTI-012a — Documento de Escopo (As-Is / To-Be)

- Versão do documento: 1.0
- Data: {today_str}
- Responsável: Equipe iTracker

## 1. Objetivo do Sistema
- **[As-Is]** Plataforma de gestão e reprodução de conteúdo em TVs (Web/Android/Windows players via browser e Chromecast), com:
  - Cadastro e upload de conteúdos (imagens, vídeos, HTML/texto) — `backend/routes/content.py`.
  - Criação de campanhas com múltiplos conteúdos e ordenação — `backend/models/campaign.py` e `backend/routes/campaign.py`.
  - Agendamentos com todas as regras de reprodução (slot main/overlay, duração, modo) — `backend/routes/schedule.py` e `backend/services/schedule_executor.py`.
  - Players gerenciáveis por empresa/sede, com short-link público para kiosk — `backend/routes/player.py`, `backend/app.py`.
  - KPIs de reprodução em tempo real e painel — `backend/routes/dashboard.py` e eventos Socket.IO em `backend/app.py`.
  - Monitoramento de tráfego por player (bytes/tipo/status HTTP) — instrumentação em `/uploads` em `backend/app.py`.
- **[To-Be]** Aprimorar analytics (relatórios por campanha/player), ampliar suporte a players nativos (Android/Windows), e governança centralizada de parâmetros (limiares de tráfego e retenção) pelo `SystemConfig`.

## 2. Escopo Funcional
- Conteúdo: upload, listagem, edição, exclusão, thumbnails e detecção de duração de vídeos (`ffmpeg/ffprobe`).
- Campanhas: múltiplos conteúdos por campanha, reordenação, filtros por local/dia/horas, vídeo compilado opcional.
- Agendamentos: configuração única das regras de reprodução no agendamento (sequencial, aleatório, single, loop; slot main/overlay; persistência; prioridade).
- Players: cadastro/edição; plataforma (web/android/windows/chromecast), `device_type` (modern/tizen/legacy), short-link com `access_code`, status online/offline, métricas básicas.
- Reprodução: executor com suporte a overlay+main simultâneos; Chromecast via `chromecast_service`; players web via Socket.IO.
- Autenticação e RBAC: JWT, papéis `admin/manager/hr/user`, escopo por `company` para RH (Users/Players/Locations/Schedules).
- Monitoramento: KPIs de reprodução em tempo real e métricas de tráfego por player em `/uploads` (ETag/206/304/contadores).

## 3. Escopo Não Funcional
- Disponibilidade: Scheduler em background `APScheduler` (minutal). Socket.IO com polling para estabilidade LAN.
- Performance: Cache HTTP/ETag para `/uploads`, compilação de vídeos de campanha (quando aplicável), prefetch no WebPlayer.
- Segurança: JWT obrigatório em `/api/*` (exceto endpoints públicos de kiosk/conexão). CORS aberto para `/api/*` e `/uploads/*`. Limite de upload (100MB).
- Observabilidade: logs em rotas e serviços principais; métricas básicas de tráfego; endpoints de debug: `/api/dashboard/debug/players`.

## 4. Escopo Fora do Projeto
- Integração com sistemas externos de billing, ERP, e cobrança automática.
- CDN externa de mídia (uso atual é via `/uploads` local).

## 5. Regras de Negócio e Usuários
- Papéis: `admin` (total), `manager` (gestão), `hr` (recursos humanos com escopo por empresa), `user` (básico).
- HR só vê/gera players/locations/schedules da própria empresa.
- Agendamento controla todas as regras de playback (campanha é apenas container de conteúdos).

## 6. Restrições
- Banco de dados SQLite em `backend/instance/tvs_platform.db`.
- Tamanho máximo de upload: 100 MB (`MAX_CONTENT_LENGTH`).

## 7. Premissas
- Players Web/Android/Windows abrem URL pública do kiosk (`/k/<code>` → `/kiosk/player/:id`).
- Chromecast acessível na mesma LAN do servidor para descoberta e streaming.

## 8. Entregáveis
- Backend Flask com APIs REST e Socket.IO (`backend/app.py`, `backend/routes/`).
- Frontend React SPA (painel admin em `/app`, kiosk em `/kiosk/player/:id`).
- Executor de agendamentos e serviço Chromecast.
- Documentação de arquitetura e as-built.

## 9. Critérios de Aceite
- Upload e gestão de conteúdos; campanhas com múltiplos itens; criação de agendamentos e reprodução conforme regras; KPIs em painel; short-link do player funcional; Chromecast executando mídia; RBAC efetivo.

## 10. Riscos e Mitigações
- Descoberta zeroconf instável: mecanismo de recriação e circuit breaker em `chromecast_service.py`.
- Players aparentando online sem reproduzir: heartbeats de reprodução e KPIs em tempo real (telemetria Socket.IO).
- LAN sem WebSocket: forçar polling em TVs e navegadores do kiosk.

## 11. Planejamento de Evolução (Backlog To-Be)
- Relatórios detalhados (por campanha/player/empresa) e exportação.
- Persistência minuto/hora/dia de tráfego em tabelas dedicadas e endpoints timeseries (planejado).
- Players nativos com cache offline robusto.

## 12. Cronograma / Custos
- Preenchimento manual posterior.

## 13. Aprovações
- Preenchimento manual posterior.
"""

    # Conteúdo: PLTI-012b
    content_012b = f"""
# PLTI-012b — Arquitetura de TI (To-Be)

## 1. Visão Geral
- Camadas:
  - Frontend React SPA (`src/`) com Admin (`/app/*`) e Kiosk (`/kiosk/player/:id`).
  - Backend Flask (`backend/app.py`), Blueprints em `backend/routes/`, serviços em `backend/services/`, Socket.IO e `APScheduler`.
  - Armazenamento local (`uploads/`) e DB SQLite em `backend/instance/tvs_platform.db`.

## 2. Backend
- Framework: Flask + Flask-JWT-Extended + Flask-SocketIO + APScheduler.
- Blueprints principais: Auth, Content, Campaign, Schedule, Player, Dashboard, Settings, Cast.
- Realtime: eventos `join_player`, `join_admin`, `playback_event` em `backend/app.py`.
- Jobs: verificação de agendamentos (executor), sync de players (AutoSyncService), métricas de tráfego periódicas.
- Serviços:
  - `schedule_executor.py`: overlay+main, rotação, suporte a vídeo compilado.
  - `chromecast_service.py`: descoberta zeroconf, reconexão, circuit breaker, thread-safe.
  - `auto_sync_service.py`: descobre dispositivos e atualiza status.
  - `distribution_manager.py`: distribuição de conteúdos.
- Segurança: JWT; CORS em `/api/*`, `/uploads/*`, `/socket.io/*`.
- Performance: ETag/206/304 e `Cache-Control` para `/uploads`; playlist com ETag/If-None-Match.

## 3. Frontend
- SPA com roteamento base em `/app` e modo kiosk em `/kiosk/player/:id`.
- Kiosk: PlayerView com polling/Socket.IO.
- Admin: Campanhas/Conteúdo/Players/Agendamentos, KPIs e Tráfego.

## 4. Banco de Dados (SQLite)
- Entidades: `User`, `Location`, `Content`, `Campaign`, `CampaignContent`, `Schedule`, `Player`, `PlaybackEvent`, `SystemConfig`, `ContentDistribution`.
- Observações: `Player` armazena telemetria de reprodução; `Campaign` como container; regras no `Schedule`.

## 5. Integrações e Endpoints Públicos
- Short-link `/k/<code>` → `/api/players/resolve-code/<code>` → `/kiosk/player/<id>`.
- Playlist pública: `/api/players/<id>/playlist`.
- Info pública: `/api/players/<id>/info`.
- Conexão/Presença: `/api/players/<id>/connect`.
- Uploads com ETag: `/uploads/<file>`.

## 6. Operação e Deploy
- Build React servido por `backend/app.py` se presente em `backend/build`.
- Scripts `deploy-tv.bat` / `deploy-tv.sh`.
- ProxyFix habilitado para ambientes com proxy.

## 7. To-Be Arquitetural
- Migrar Socket.IO para WebSocket pleno (eventlet/gevent) em produção.
- Persistência de séries históricas de tráfego e endpoints agregados.
- Considerar PostgreSQL para multi-instância.
"""

    # Conteúdo: PLTI-012c
    content_012c = f"""
# PLTI-012c — As Built

## 1. Decisões de Design
- Regras de reprodução consolidadas no `Schedule`; campanha é container.
- Controle overlay+main com tracking independente no executor.
- ETag e `?pid=<player_id>` em mídia para atribuir tráfego; playlist com ETag/If-None-Match.
- Short-link `/k/<code>` com `/api/players/resolve-code/<code>`; landing `/tv`.
- Socket.IO em polling por estabilidade.

## 2. Endpoints e Fluxos
- Conteúdos: `/api/content` (CRUD), thumbnails e mídia servidos conforme rotas de conteúdo.
- Players: CRUD com RBAC; públicos `/api/players/<id>/info`, `/api/players/<id>/playlist`, `/api/players/<id>/connect`; sync manual `/api/players/sync-all`.
- Kiosk: `/k/<code>` → `/kiosk/player/<id>?fullscreen=true`.
- Dashboard/KPIs: `/api/dashboard/stats`, `/api/dashboard/playback-status`, `/api/dashboard/health`, `/api/dashboard/alerts`.

## 3. Modelos e Migrações
- Entidades: `User`, `Location`, `Content`, `Campaign`, `CampaignContent`, `Schedule`, `Player`, `PlaybackEvent`, `SystemConfig`, `ContentDistribution`.
- Campos críticos em `Player`: `is_playing`, `current_content_*`, `playback_start_time`, `last_playback_heartbeat`, `device_type`, `access_code`.

## 4. Telemetria de Reprodução
- Eventos REST/Socket.IO: `playback_start`, `playback_heartbeat`, `playback_end` atualizam colunas e emitem `playback_status_update`.

## 5. Monitoramento de Tráfego
- Instrumentação no handler de `/uploads` com contagem por status/bytes/latência e emissão periódica `traffic_stats`.

## 6. Correções e Estabilidade
- `is_online` robusto para strings; exclusões seguras de conteúdo via SQL direto; Chromecast com reconexão por UUID/nome e circuit breaker zeroconf.

## 7. Banco de Dados e Operação
- DB: `backend/instance/tvs_platform.db`.
- Scheduler minutal; logs em `backend/logs.txt` (quando habilitado);
- Build React opcional em `backend/build`.

## 8. Limitações Conhecidas
- WebSocket pleno não habilitado por padrão (polling).
- Sem histórico persistente de tráfego (snapshot/buckets recentes).

## 9. Custos/Financeiro
- Preenchimento manual posterior.
"""

    # Conteúdo: PLTI-012d
    content_012d = f"""
# PLTI-012d — Plano de Manutenção e Suporte da Aplicação

## 1. Rotinas de Manutenção
- Banco de Dados:
  - Backup periódico de `backend/instance/tvs_platform.db`.
  - Verificação de integridade e `VACUUM` ocasional.
- Arquivos:
  - Monitorar espaço em `uploads/` e limpar mídias obsoletas com checagem de referência.
- Aplicação:
  - Verificar jobs `APScheduler` (minutal) e revisar logs.
  - Revisar `SystemConfig` (intervalos/flags de métricas).

## 2. Monitoramento e Alertas
- KPIs: `/api/dashboard/playback-status` para playing/idle/ghost.
- Saúde: `/api/dashboard/health` com uptime e status.
- Tráfego: evento `traffic_stats` via Socket.IO, contadores por status em `/uploads`.
- Players: heartbeats de reprodução e ping de presença (`/api/players/<id>/connect`).

## 3. Procedimentos de Incidente
- Chromecast: executar `/api/players/sync-all`, validar `chromecast_id` vs nome, revisar logs do zeroconf e forçar reconexão.
- Kiosk: testar acesso via IP (LAN), confirmar polling Socket.IO e baseURL do Axios.
- Agendamentos: validar formatos HH:MM e `Schedule.is_active_now()`.

## 4. Atualizações e Deploy
- Backend: `pip install -r requirements.txt` e restart do serviço.
- Frontend: build em `backend/build`; validar rotas `/app/*` e `/kiosk/player/:id`.
- Scripts auxiliares: `deploy-tv.bat` / `deploy-tv.sh`.

## 5. Segurança e Acesso
- JWT e papéis (admin/manager/hr/user).
- Reset de senha: `/api/auth/users/<user_id>/set-password` (admin).

## 6. Backup e Restauração
- Backup diário do DB e `uploads/`.
- Restore com serviço parado e consistência entre DB e arquivos.

## 7. SLAs e Custos
- Preenchimento manual posterior.

## 8. Contatos/Escalação
- Preenchimento manual posterior.
"""

    # Escrever documentos
    mapping = [
        (p012a, content_012a),
        (p012b, content_012b),
        (p012c, content_012c),
        (p012d, content_012d),
    ]

    for path, md in mapping:
        if os.path.exists(path):
            write_document(path, md)
            print(f"[OK] Preenchido: {os.path.basename(path)}")
        else:
            print(f"[WARN] Arquivo não encontrado, ignorado: {path}")

    # Remover .md auxiliar, se existir
    if args.remove_md:
        md_012a = os.path.join(docs_dir, 'PLTI-012a - Documento_de_Escopo_As_is_To_be.md')
        if os.path.exists(md_012a):
            try:
                os.remove(md_012a)
                print(f"[OK] Removido arquivo auxiliar: {md_012a}")
            except Exception as e:
                print(f"[WARN] Falha ao remover {md_012a}: {e}")


if __name__ == '__main__':
    main()
